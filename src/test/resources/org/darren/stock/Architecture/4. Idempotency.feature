@section-Architecture @asciidoc @order-3
Feature: Architecture Overview - Idempotency

  ## Idempotency for State-Changing Operations

  The Stock API implements idempotency for all state-changing operations (POST requests) to ensure that duplicate
  requests do not cause unintended side effects or data mutations.

  ### Request Identification

  All state-changing operations REQUIRE a `requestId` field in the request body to ensure safe retryability:

  ```json
  {
    "requestId": "550e8400-e29b-41d4-a716-446655440000",
    "quantity": 10.0,
    ...
  }
  ```

  - The `requestId` is **mandatory** - requests without it will fail with 400 Bad Request
  - The `requestId` should be a unique identifier (UUID recommended) generated by the client
  - The same `requestId` must be used for all retry attempts of the same logical operation
  - This ensures all operations are safely retryable by default, preventing accidental duplicate mutations

  ### Behavior

  **First Request** (with requestId):
  - The server processes the request normally
  - A SHA-256 hash of the request body is computed for content validation
  - Business logic executes and state changes are applied
  - The response (status code, headers, and body) is cached using the `requestId` as the key
  - The body hash is stored with the cached response
  - Returns 201 Created with the response body

  **Duplicate Request** (same requestId, same content):
  - The server detects the duplicate by checking the cache
  - The request body hash is computed and compared with the cached hash
  - If hashes match: Business logic does NOT execute (no state mutations occur)
  - The cached response is returned exactly as it was for the first request
  - Returns 201 Created with the same response body (indistinguishable from first request)
  - Logs: "Returning cached response for duplicate requestId: {id}"

  **Duplicate RequestId with Different Content** (same requestId, different body):
  - The server detects the duplicate requestId in the cache
  - The request body hash is computed and does NOT match the cached hash
  - This indicates the client is incorrectly reusing a requestId for different operations
  - Returns 409 Conflict with error message explaining the requestId conflict
  - Business logic does NOT execute (protects data integrity)
  - Logs warning about requestId reuse with different content
  - Stock levels remain unchanged

  **Request without requestId**:
  - Returns 400 Bad Request with deserialization error
  - The `requestId` field is required for all state-changing operations
  - This ensures clients implement proper retry logic

  ### Implementation Details

  - **Duplicate Detection**: Domain-level event sourcing used by `StockPotActor.checkIdempotency()` for reliable duplicate detection
  - **Storage**: Event history stored in `StockEventRepository` (in-memory for tests, persistent for production)
  - **Duplicate Key**: Combination of `requestId` and content hash stored in event metadata
  - **Content Validation**: SHA-256 hash of request content compared against existing events
  - **Domain Metrics**: OpenTelemetry counters track `idempotency.domain.hits` and `idempotency.domain.misses`
  - **Actor Isolation**: Each stock pot maintains its own idempotency state via event sourcing
  - **Single Body Read**: Request body is read once at HTTP level and `requestId` passed to domain layer
  - **Error Caching**: Only successful responses (2xx) are cached; 4xx and 5xx responses are not cached

  ### Endpoints with Idempotency Support

  All state-changing operations support idempotent behavior:
  - POST `/locations/{locationId}/products/{productId}/sales` - Record sale
  - POST `/locations/{locationId}/deliveries` - Record delivery
  - POST `/locations/{sourceLocationId}/products/{productId}/move` - Move stock
  - POST `/locations/{locationId}/products/{productId}/counts` - Count stock

  ### Error Scenarios (Future Enhancement)

  - **5xx Errors**: Should NOT be cached - allow retries (already implemented: 5xx responses are not cached)
  - **4xx Errors**: 4xx responses are not cached (validation errors are not stored)
  - **Content Mismatch**: Different request body with same requestId - detected via body hash and returns `409 Conflict` to the client

  ### Best Practices for Clients

  1. Generate a unique `requestId` (UUID v4) for each logical operation
  2. Use the same `requestId` for all retry attempts of that operation
  3. Do not reuse `requestId` values across different operations
  4. Always include `requestId` - it is mandatory for all state-changing operations
  5. Handle 400 Bad Request errors if `requestId` is accidentally omitted

  ### Example Flow

  ```
  Client Request 1: POST /locations/Store-001/products/SKU123/sales
  {
    "requestId": "abc-123",
    "quantity": 5.0,
    "soldAt": "2024-12-14T10:00:00Z"
  }
  Server: Processes sale, reduces stock from 50 to 45, caches response
  Response: 201 Created { "requestId": "abc-123", "locationId": "Store-001", ... }

  Client Request 2 (retry): POST /locations/Store-001/products/SKU123/sales
  {
    "requestId": "abc-123",  # Same ID
    "quantity": 5.0,
    "soldAt": "2024-12-14T10:00:00Z"
  }
  Server: Detects duplicate, returns cached response, stock remains 45
  Response: 201 Created { "requestId": "abc-123", "locationId": "Store-001", ... }
  ```

  ### Related Test Scenarios

  See the following features for concrete test scenarios:
  - `Sales/2. Sale Contract.feature` - "Handle duplicate sale request using the same requestId"
  - `Deliveries/2. Delivery Contract.feature` - "Handle duplicate delivery request using the same requestId"
  - `Move/2. Movement Contract.feature` - "Handle duplicate movement request using the same requestId"
  - `Counts/AdminOverride.feature` - "Handle duplicate stock count creation with the same requestId"
